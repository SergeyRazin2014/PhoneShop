/* ВСЕ СЕЛЕКТОРЫ ВЫТАЩИЛИ В ОТДЕЛЬНЫЙ ФАЙЛ Т.К. ТАК МОЖНО ЭТИ ФУНКЦИИ ПЕРЕЕИСПОЛЬЗОВАТЬ И ЛЕГЧЕ ТЕСТИРОВАТЬ И КОД В КОМПОНЕНТАХ НЕ ЗАСИРАЕТСЯ */
/* ТУТ ВСЕ ФУНКЦИИ ЭТО PURE ФУНКЦИИ ОНИ НИЧЕГО НЕ МУТИРУЮТ */

import * as R from 'ramda';

//@ выбрать телефон из списка телефонов по id
export const getPhoneById = (state, id) => {
    return R.prop(id, state.phones);  // это тоже самое: return state.phones[id];
}

//@ выбрать телефоны только с id такими-то
export const getPhones = (state) => {

    //найти телефоны по id
    const phones = R.map(id => getPhoneById(state, id), state.phonesPage.ids);//это аналог обычному map (из списка id получаем телефоны как бы) //как он работает: первый аргумент - это функция предикат которая вызывается для каждого итема, второй аргумент - это наш список итемов
    return phones;
}

//@
export const getRenderedPhonesLength = (state) => {
    return R.length(state.phonesPage.ids);
}

//@
export const getTotalBasketCount = (state) => {
    return state.basket.length;
}

//@
const isPhoneInList = (id, ) => {

}

//@
export const getTotalBasketPrice = (state) => {

    if (state.basket && state.basket.length <= 0) {
        return 0;
    }

    // state.basket -> это массив с id телефонов которые в карзине
    // state.phones - это не массив а объект, св-ва которого это цифры т.е. id-шники телефонов (зачем-то ведущий курса так изуродовал простой массив телефонов)

    const totalPrice = R.compose(
        R.sum,
        R.pluck('price'),
        R.map(id => getPhoneById(state, id))
    )(state.basket);

    return totalPrice;
}
