/* ВСЕ СЕЛЕКТОРЫ ВЫТАЩИЛИ В ОТДЕЛЬНЫЙ ФАЙЛ Т.К. ТАК МОЖНО ЭТИ ФУНКЦИИ ПЕРЕЕИСПОЛЬЗОВАТЬ И ЛЕГЧЕ ТЕСТИРОВАТЬ И КОД В КОМПОНЕНТАХ НЕ ЗАСИРАЕТСЯ */
/* ТУТ ВСЕ ФУНКЦИИ ЭТО PURE ФУНКЦИИ ОНИ НИЧЕГО НЕ МУТИРУЮТ */

import * as R from 'ramda'

//@ выбрать телефон из списка телефонов по id
export const getPhoneById = (state, id) => {
  const result = R.prop(id, state.phones)  // это тоже самое: return state.phones[id];
  return result
}

//@
export const getActiveCategoryId = (ownProps) => {
  const result = R.path(['match', 'params', 'id'], ownProps)  //ЭТО АНАЛОГ ownProps?.match?.params?.id - ЕСЛИ ОДНО ИЗ СВОЙСТВ undefined - ТО ВЕРНЕТСЯ undefined
  return result
}

//@ выбрать телефоны только с id такими-то
export const getPhones = (state, ownProps) => {

  //найти телефоны по id
  // const phones = R.map(id => getPhoneById(state, id), state.phonesPage.ids);//это аналог обычному map (из списка id получаем телефоны как бы) //как он работает: первый аргумент - это функция предикат которая вызывается для каждого итема, второй аргумент - это наш список итемов
  // return phones;

  const activeCategoryId = getActiveCategoryId(ownProps)  //ПОЛУЧАЕМ АКТИВНУЮ КАТЕГОРИЮ


  const applySearch = item => R.contains(state.phonesPage.search, item.name) //поиск подстроки в строке

  //тупо берем из редюсера значение которое забили в поле поиск и фильтруем по нему список телефонов, если в поиск ничего не заибили то будет пустая строка и мы получим все телефоны как бы
  const phones = R.compose(  //это какашка за одно и осуществляет поиск телефонов т.е. из компонента search
    R.filter(applySearch),
    R.map(id => getPhoneById(state, id))
  )(state.phonesPage.ids)

  //ЕСЛИ АКТИВНАЯ КАТЕГОРИЯ УКАЗАНА ТО ФИЛЬТРУЕМ ПО ЭТОЙ КАТЕГОРИИ
  if (activeCategoryId) {
    return phones.filter(x => x.categoryId == activeCategoryId)
  }

  return phones

}

//@
export const getRenderedPhonesLength = (state) => {
  return R.length(state.phonesPage.ids)
}

//@
export const getTotalBasketCount = (state) => {
  return state.basket.length
}

//@
const isPhoneInList = (id) => {

}

//@
export const getTotalBasketPrice = (state) => {

  if (state.basket && state.basket.length <= 0) {
    return 0
  }

  // state.basket -> это массив с id телефонов которые в карзине
  // state.phones - это не массив а объект, св-ва которого это цифры т.е. id-шники телефонов (зачем-то ведущий курса так изуродовал простой массив телефонов)

  const totalPrice = R.compose(
    R.sum,
    R.pluck('price'),
    R.map(id => getPhoneById(state, id))
  )(state.basket)

  return totalPrice
}

//@
export const getCategories = (state) => {
  return R.values(state.categories) // ВЕДУЩИЙ ДАУН СНАЧАЛА ВСЕ ЗАВЕРНУЛ В ОБЪЕКТ ГДЕ КЛЮЧИ - ЭТО ID КАТЕГОРИЙ, А ТУТ ОН РАЗВОРАЧИВАТЕ ВСЕ НАЗАД В МАССИВ КАТЕГОРИЙ
}

//@ ПОЛУЧАЕМ ПО IDS ТЕЛЕФОНЫ КОТОРЫЕ В КАРЗИНЕ И ДОБАВЛЯЕМ ЭТИМ ОБЪЕКТАМ ТЕЛЕФОНОВ ПОЛЕ COUNT
export const getBasketPhonesWithCount = (state) => {
  const phoneIdsInBasket = state.basket
  const uniqueIds = R.uniq(phoneIdsInBasket)  //ПОЛУЧАЕМ УНИКАЛЬНЫЕ ID ТЕЛЕФОНОВ В КАРЗИНЕ

  //ДЛЯ КАЖДОГО ID ТЕЛЕФОНА
  //  ПОЛУЧИТЬ ТЕЛЕФОН ИЗ СПИСКА
  //  ДОБАВИТЬ ЭТОМУ ТЕЛЕФОНУ СВ-ВО COUNT

  const phonesResult = []

  for (let phoneId of uniqueIds) {
    const phone = getPhoneById(state, phoneId)

    const phoneCount = phoneIdsInBasket.filter(x => x == phoneId).length

    phone.count = phoneCount
    phonesResult.push(phone)
  }

  return phonesResult

}
